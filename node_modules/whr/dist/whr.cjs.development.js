'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

var PlayerDay = /*#__PURE__*/function () {
  // TODO: Find out what day type is
  function PlayerDay(player, day) {
    this.player = player;
    this.day = day;
    this.isFirstDay = false;
    this.wonGames = [];
    this.lostGames = [];
    this._wonGameTerms = null;
    this._lostGameTerms = null;
    this.uncertainty = null;
  }

  var _proto = PlayerDay.prototype;

  _proto.clearGameTermsCache = function clearGameTermsCache() {
    this._wonGameTerms = null;
    this._lostGameTerms = null;
  };

  _proto.addGame = function addGame(game) {
    if (game.winner == "W" && game.whitePlayer === this.player || game.winner == "B" && game.blackPlayer === this.player) {
      this.wonGames.push(game);
    } else {
      this.lostGames.push(game);
    }
  };

  _proto.updateBy1DNewtonsMethod = function updateBy1DNewtonsMethod() {
    var dlogp = this.logLikelihoodDerivative;
    var d2logp = this.logLikelihoodSecondDerivative;
    var dr = dlogp / d2logp;
    var new_r = this.r - dr;
    this.r = new_r;
  };

  _createClass(PlayerDay, [{
    key: "gamma",
    set: function set(gamma) {
      this.r = Math.log(gamma);
    },
    get: function get() {
      return Math.exp(this.r);
    }
  }, {
    key: "elo",
    set: function set(elo) {
      this.r = elo * (Math.log(10) / 400.0);
    },
    get: function get() {
      return this.r * 400.0 / Math.log(10);
    }
  }, {
    key: "logLikelihood",
    get: function get() {
      return 0;
    }
  }, {
    key: "wonGameTerms",
    get: function get() {
      var _this = this;

      if (!this._wonGameTerms) {
        this._wonGameTerms = this.wonGames.map(function (g) {
          var otherGamma = g.opponentsAdjustedGamma(_this.player);

          if (otherGamma === 0 || isNaN(otherGamma) || !isFinite(otherGamma)) {
            throw new UnstableRatingException("otherGamma (" + g.opponent(_this.player).inspect + ") = " + otherGamma);
          }

          return [1.0, 0.0, 1.0, otherGamma];
        });

        if (this.isFirstDay) {
          this._wonGameTerms.push([1.0, 0.0, 1.0, 1.0]); // win against virtual player ranked with gamma = 1.0

        }
      }

      return this._wonGameTerms;
    }
  }, {
    key: "lostGameTerms",
    get: function get() {
      var _this2 = this;

      if (!this._lostGameTerms) {
        this._lostGameTerms = this.lostGames.map(function (g) {
          var otherGamma = g.opponentsAdjustedGamma(_this2.player);

          if (otherGamma === 0 || isNaN(otherGamma) || !isFinite(otherGamma)) {
            console.log("otherGamma (" + g.opponent(_this2.player).inspect + ") = " + otherGamma);
          }

          return [0.0, otherGamma, 1.0, otherGamma];
        });

        if (this.isFirstDay) {
          this._lostGameTerms.push([0.0, 1.0, 1.0, 1.0]); // loss against virtual player ranked with gamma = 1.0

        }
      }

      return this._lostGameTerms;
    }
  }, {
    key: "logLikelihoodSecondDerivative",
    get: function get() {
      var _this3 = this;

      var sum = 0.0;
      var terms = this.wonGameTerms.concat(this.lostGameTerms);
      terms.forEach(function (term) {
        var c = term[2],
            d = term[3];
        sum += c * d / Math.pow(c * _this3.gamma + d, 2.0);
      });
      if (isNaN(this.gamma)) throw new UnstableRatingException("Gamma cannot be NaN");
      if (isNaN(sum)) throw new UnstableRatingException("Sum cannot be NaN");
      return -1 * this.gamma * sum;
    }
  }, {
    key: "logLikelihoodDerivative",
    get: function get() {
      var _this4 = this;

      var tally = 0;
      var terms = this.wonGameTerms.concat(this.lostGameTerms);
      terms.forEach(function (term) {
        var c = term[2],
            d = term[3];
        tally += c / (c * _this4.gamma + d);
      });
      return this.wonGameTerms.length - this.gamma * tally;
    }
  }]);

  return PlayerDay;
}();

var Player = /*#__PURE__*/function () {
  //:days, :w2, :debug, :id
  function Player(name, config) {
    this.name = name;
    this.days = [];
    this.debug = config.debug;
    this.w2 = Math.pow(Math.sqrt(config.w2) * Math.log(10) / 400, 2); // Convert from elo^2 to r^2
  }

  var _proto = Player.prototype;

  _proto.hessian = function hessian(days, sigma2) {
    var n = days.length; // Create an n by n matrix

    var matrix = new Array(n).fill(new Array(n).fill(null));
    return matrix.map(function (_y, row) {
      return _y.map(function (_x, col) {
        if (row == col) {
          var prior = 0;
          if (row < n - 1) prior += -1.0 / sigma2[row];
          if (row > 0) prior += -1.0 / sigma2[row - 1];
          return days[row].logLikelihoodSecondDerivative + prior - 0.001;
        } else if (row == col - 1) {
          return 1.0 / sigma2[row];
        } else if (row == col + 1) {
          return 1.0 / sigma2[col];
        } else {
          return 0;
        }
      });
    });
  };

  _proto.gradient = function gradient(r, days, sigma2) {
    var _this = this;

    var g = [];
    var n = this.days.length;
    days.forEach(function (day, idx) {
      var prior = 0;
      if (idx < n - 1) prior += -(r[idx] - r[idx + 1]) / sigma2[idx];
      if (idx > 0) prior += -(r[idx] - r[idx - 1]) / sigma2[idx - 1];
      if (_this.debug) console.log("g[" + idx + "] = " + day.logLikelihoodDerivative + " + " + prior);
      g.push(day.logLikelihoodDerivative + prior);
    });
    return g;
  };

  _proto.runOneNewtonIteration = function runOneNewtonIteration() {
    this.days.forEach(function (day) {
      day.clearGameTermsCache();
    });

    if (this.days.length == 1) {
      this.days[0].updateBy1DNewtonsMethod();
    } else if (this.days.length > 1) {
      this.updateByNDimNewton();
    }
  };

  _proto.computeSigma2 = function computeSigma2() {
    var _this2 = this;

    var sigma2 = [];
    this.days.forEach(function (d1, i) {
      if (i == 0) return;
      var d2 = _this2.days[i - 1];
      sigma2.push(Math.abs(d2.day - d1.day) * _this2.w2);
    });
    return sigma2;
  };

  _proto.updateByNDimNewton = function updateByNDimNewton() {
    var _this3 = this;

    // r
    var r = this.days.map(function (day) {
      return day.r;
    });

    if (this.debug) {
      console.log("Updating " + this.inspect);
      this.days.forEach(function (day) {
        console.log("day[" + day.day + "] r = " + day.r);
        console.log("day[" + day.day + "] win terms = " + day.wonGameTerms);
        console.log("day[" + day.day + "] win games = " + day.wonGames);
        console.log("day[" + day.day + "] lose terms = " + day.lostGameTerms);
        console.log("day[" + day.day + "] lost games = " + day.lostGames);
        console.log("day[" + day.day + "] log(p) = " + day.logLikelihood);
        console.log("day[" + day.day + "] dlp = " + day.logLikelihoodDerivative);
        console.log("day[" + day.day + "] dlp2 = " + day.logLikelihoodSecondDerivative);
      });
    } // sigma squared (used in the prior)


    var sigma2 = this.computeSigma2();
    var h = this.hessian(this.days, sigma2);
    var g = this.gradient(r, this.days, sigma2);
    var a = [];
    var d = [h[0][0]];
    var b = [h[0][1]];
    var n = r.length;

    for (var i = 1; i < n; i++) {
      a[i] = h[i][i - 1] / d[i - 1];
      d[i] = h[i][i] - a[i] * b[i - 1];
      b[i] = h[i][i + 1];
    }

    var y = [g[0]];

    for (var _i = 1; _i < n; _i++) {
      y[_i] = g[_i] - a[_i] * y[_i - 1];
    }

    var x = [];
    x[n - 1] = y[n - 1] / d[n - 1];

    for (var _i2 = n - 2; _i2 >= 0; _i2--) {
      x[_i2] = (y[_i2] - b[_i2] * x[_i2 + 1]) / d[_i2];
    } // JS Array.zip implementation


    var newR = a.map(function (e, i) {
      return [e, x[i]];
    }).map(function (i) {
      return i[0] - i[1];
    });
    newR.forEach(function (r) {
      if (r > 650) throw new UnstableRatingException("Unstable r (" + newR + ") on player " + _this3.inspect);
    });

    if (this.debug) {
      console.log("Hessian = " + h);
      console.log("gradient = " + g);
      console.log("a = " + a);
      console.log("d = " + d);
      console.log("b = " + b);
      console.log("y = " + y);
      console.log("x = " + x);
      console.log(this.inspect + " (" + r + ") => (" + newR + ")");
    }

    this.days.forEach(function (day, idx) {
      day.r = day.r - x[idx];
    });
  };

  _proto.updateUncertainty = function updateUncertainty() {
    if (this.days.length > 0) {
      var c = this.covariance;
      var u = this.days.map(function (_e, i) {
        return c[i][i];
      });
      var zipped = this.days.map(function (d, i) {
        return [d, u[i]];
      }).map(function (e) {
        return e[0].uncertainty = e[1];
      });
      return zipped;
    } else return 5;
  };

  _proto.addGame = function addGame(game) {
    var lastDay = this.days.slice(-1)[0];

    if (!lastDay || lastDay.day != game.day) {
      var newPday = new PlayerDay(this, game.day);

      if (this.days.length == 0) {
        newPday.isFirstDay = true;
        newPday.gamma = 1;
      } else {
        newPday.gamma = lastDay.gamma;
      }

      lastDay = newPday;
      this.days.push(newPday);
    }

    if (game.whitePlayer === this) {
      game.wpd = lastDay;
    } else {
      game.bpd = lastDay;
    }

    lastDay.addGame(game);
  };

  _createClass(Player, [{
    key: "inspect",
    get: function get() {
      return "<Player:" + Object.entries(this).map(function (arr) {
        return arr[0] + "=" + arr[1];
      }).join(',') + ">";
    }
  }, {
    key: "logLikelihood",
    get: function get() {
      var sum = 0.0;
      var sigma2 = this.computeSigma2();
      var days = this.days;
      var n = days.length;

      for (var i = 0; i < n; i++) {
        var prior = 0;

        if (i < n) {
          var rd = days[i].r - days[i + 1].r;
          prior += 1 / Math.sqrt(2 * Math.PI * sigma2[i]) * Math.exp(-Math.pow(rd, 2) / 2 * sigma2[i]);
        }

        if (i > 0) {
          var _rd = days[i].r - days[i - 1].r;

          prior += 1 / Math.sqrt(2 * Math.PI * sigma2[i - 1]) * Math.exp(-Math.pow(_rd, 2) / 2 * sigma2[i - 1]);
        }

        if (prior == 0) {
          sum += days[i].logLikelihood;
        } else {
          if (!isFinite(days[i].logLikelihood) || !isFinite(Math.log(prior))) {
            throw new UnstableRatingException("Infinity at " + this.inspect + ": " + days[i].logLikelihood + " + " + Math.log(prior) + ": prior = " + prior + ", days = " + JSON.stringify(this.days));
          }

          sum += days[i].logLikelihood + Math.log(prior);
        }
      }

      return sum;
    }
  }, {
    key: "covariance",
    get: function get() {
      var r = this.days.map(function (day) {
        return day.r;
      });
      var sigma2 = this.computeSigma2();
      var h = this.hessian(this.days, sigma2); //let g = this.gradient(r, this.days, sigma2)

      var n = this.days.length;
      var a = [];
      var d = [h[0][0]];
      var b = [h[0][1]];
      n = r.length;

      for (var i = 1; i < n; i++) {
        a[i] = h[i][i - 1] / d[i - 1];
        d[i] = h[i][i] - a[i] * b[i - 1];
        b[i] = h[i][i + 1];
      }

      var dp = [];
      dp[n - 1] = h[n - 1][n - 1];
      var bp = [];
      bp[n - 1] = h[n - 1][n - 2];
      var ap = [];

      for (var _i3 = n - 2; _i3 >= 0; _i3--) {
        ap[_i3] = h[_i3][_i3 + 1] / dp[_i3 + 1];
        dp[_i3] = h[_i3][_i3] - ap[_i3] * bp[_i3 + 1];
        bp[_i3] = h[_i3][_i3 - 1];
      }

      var v = [];

      for (var _i4 = 0; _i4 < n - 1; _i4++) {
        v[_i4] = dp[_i4 + 1] / (b[_i4] * bp[_i4 + 1] - d[_i4] * dp[_i4 + 1]);
      }

      v[n - 1] = -1 / d[n - 1];
      var matrix = new Array(n).fill(new Array(n).fill(null));
      return matrix.map(function (_y, row) {
        return _y.map(function (_x, col) {
          if (row == col) return v[row];else if (row == col - 1) return -1 * a[col] * v[col];else return 0;
        });
      });
    }
  }]);

  return Player;
}();

var Game = /*#__PURE__*/function () {
  function Game(black, white, winner, timeStep, handicap, extras) {
    this.day = timeStep;
    this.whitePlayer = white;
    this.blackPlayer = black;
    this.winner = winner;
    this._handicap = handicap || 0;
    this.wpd = null;
    this.bpd = null;
    this.extras = extras || {};
  }

  var _proto = Game.prototype;

  _proto.opponentsAdjustedGamma = function opponentsAdjustedGamma(player) {
    var blackAdvantage = this.handicap;
    var opponentElo;
    if (player === this.whitePlayer) opponentElo = this.bpd.elo + blackAdvantage;else if (player === this.blackPlayer) opponentElo = this.wpd.elo - blackAdvantage;else throw new RatingException("No opponent for " + player.name + ", since they're not in this game: " + this + ".");
    var rval = Math.pow(10, opponentElo / 400.0);
    if (rval == 0 || !isFinite(rval) || isNaN(rval)) throw new UnstableRatingException("Bad adjusted gamma: " + this);
    return rval;
  };

  _proto.opponent = function opponent(player) {
    if (player == this.whitePlayer) return this.blackPlayer;
    return this.whitePlayer;
  };

  _createClass(Game, [{
    key: "inspect",
    get: function get() {
      return "<Game:" + Object.entries(this).map(function (arr) {
        return arr[0] + "=" + arr[1];
      }).join(',') + ">";
    }
  }, {
    key: "handicap",
    get: function get() {
      if (this._handicap instanceof Function) return this._handicap();
      return this._handicap;
    }
  }, {
    key: "predictionScore",
    get: function get() {
      if (this.whiteWinProbability == 0.5) return 0.5;else return this.winner == "W" && this.whiteWinProbability > 0.5 || this.winner == "B" && this.whiteWinProbability < 0.5 ? 1.0 : 0.0;
    } // This is the Bradley-Terry Model

  }, {
    key: "whiteWinProbability",
    get: function get() {
      return this.wpd.gamma / (this.wpd.gamma + this.opponentsAdjustedGamma(this.whitePlayer));
    }
  }, {
    key: "blackWinProbability",
    get: function get() {
      return this.bpd.gamma / (this.bpd.gamma + this.opponentsAdjustedGamma(this.blackPlayer));
    }
  }]);

  return Game;
}();

var RatingException = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RatingException, _Error);

  function RatingException() {
    return _Error.apply(this, arguments) || this;
  }

  return RatingException;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var UnstableRatingException = /*#__PURE__*/function (_RatingException) {
  _inheritsLoose(UnstableRatingException, _RatingException);

  function UnstableRatingException() {
    return _RatingException.apply(this, arguments) || this;
  }

  return UnstableRatingException;
}(RatingException);
/**
 * Base class for WHR.
 */

var WholeHistoryRating = /*#__PURE__*/function () {
  function WholeHistoryRating(config) {
    this.config = config || {};
    this.config.w2 = this.config.w2 || 300.0;
    this.games = this.config.games || [];
    this.players = this.config.players || new Map();
  }

  var _proto = WholeHistoryRating.prototype;

  _proto.printOrderedRatings = function printOrderedRatings() {
    var players = Array.from(this.players.values()).filter(function (p) {
      return p.days.length > 0;
    });
    players.forEach(function (p) {
      return console.log(p.name + " => " + p.days.map(function (day) {
        return day.elo;
      }).join(', '));
    });
  };

  _proto.logLikelihood = function logLikelihood() {
    var score = 0.0;
    Object.values(this.players).forEach(function (p) {
      if (p.days.length > 0) score += p.logLikelihood;
    });
    return score;
  };

  _proto.playerByName = function playerByName(name) {
    var player = this.players.get(name);

    if (!player) {
      player = new Player(name, this.config);
      this.players.set(name, player);
    }

    return player;
  };

  _proto.ratingsForPlayer = function ratingsForPlayer(name) {
    var player = this.playerByName(name);
    return player.days.map(function (d) {
      return [d.day, Math.round(d.elo), Math.round(d.uncertainty * 100)];
    });
  };

  _proto.setupGame = function setupGame(black, white, winner, timeStep, handicap, extras) {
    if (extras === void 0) {
      extras = {};
    }

    // Avoid self-played games (no info)
    if (black == white) {
      throw new RatingException("Invalid game, player cannot play with themself");
    }

    var whitePlayer = this.playerByName(white);
    var blackPlayer = this.playerByName(black);
    return new Game(blackPlayer, whitePlayer, winner, timeStep, handicap, extras);
  };

  _proto.createGame = function createGame(black, white, winner, timeStep, handicap, extras) {
    if (extras === void 0) {
      extras = {};
    }

    var game = this.setupGame(black, white, winner, timeStep, handicap, extras);
    return this.addGame(game);
  };

  _proto.addGame = function addGame(game) {
    game.whitePlayer.addGame(game);
    game.blackPlayer.addGame(game);

    if (!game.bpd) {
      throw new RatingException("Bad game: " + game.inspect);
    }

    this.games.push(game);
    return game;
  };

  _proto.iterate = function iterate(count) {
    for (var i = 0; i < count; i++) {
      this.runOneIteration();
    }

    this.players.forEach(function (p) {
      return p.updateUncertainty();
    });
  };

  _proto.runOneIteration = function runOneIteration() {
    this.players.forEach(function (p) {
      return p.runOneNewtonIteration();
    });
  };

  _createClass(WholeHistoryRating, [{
    key: "inspect",
    get: function get() {
      return this;
    }
  }]);

  return WholeHistoryRating;
}();

exports.Game = Game;
exports.Player = Player;
exports.PlayerDay = PlayerDay;
exports.WholeHistoryRating = WholeHistoryRating;
//# sourceMappingURL=whr.cjs.development.js.map
